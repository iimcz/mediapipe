// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wrappers.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_wrappers_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_wrappers_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "connection.pb.h"
#include "commands.pb.h"
#include "sensor.pb.h"
#include "keyboard.pb.h"
#include "mouse.pb.h"
#include "event.pb.h"
#include "mediapipe.pb.h"
#include "realsense.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_wrappers_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_wrappers_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_wrappers_2eproto;
namespace naki3d {
namespace common {
namespace protocol {
class DeviceMessage;
class DeviceMessageDefaultTypeInternal;
extern DeviceMessageDefaultTypeInternal _DeviceMessage_default_instance_;
class SensorControlMessage;
class SensorControlMessageDefaultTypeInternal;
extern SensorControlMessageDefaultTypeInternal _SensorControlMessage_default_instance_;
class SensorMessage;
class SensorMessageDefaultTypeInternal;
extern SensorMessageDefaultTypeInternal _SensorMessage_default_instance_;
class ServerMessage;
class ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
}  // namespace protocol
}  // namespace common
}  // namespace naki3d
PROTOBUF_NAMESPACE_OPEN
template<> ::naki3d::common::protocol::DeviceMessage* Arena::CreateMaybeMessage<::naki3d::common::protocol::DeviceMessage>(Arena*);
template<> ::naki3d::common::protocol::SensorControlMessage* Arena::CreateMaybeMessage<::naki3d::common::protocol::SensorControlMessage>(Arena*);
template<> ::naki3d::common::protocol::SensorMessage* Arena::CreateMaybeMessage<::naki3d::common::protocol::SensorMessage>(Arena*);
template<> ::naki3d::common::protocol::ServerMessage* Arena::CreateMaybeMessage<::naki3d::common::protocol::ServerMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace naki3d {
namespace common {
namespace protocol {

// ===================================================================

class ServerMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:naki3d.common.protocol.ServerMessage) */ {
 public:
  inline ServerMessage() : ServerMessage(nullptr) {};
  virtual ~ServerMessage();

  ServerMessage(const ServerMessage& from);
  ServerMessage(ServerMessage&& from) noexcept
    : ServerMessage() {
    *this = ::std::move(from);
  }

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerMessage& default_instance();

  enum MessageCase {
    kEncryptionInfo = 16,
    kLoadPackage = 17,
    kClearPackage = 18,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
               &_ServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ServerMessage& a, ServerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerMessage* New() const final {
    return CreateMaybeMessage<ServerMessage>(nullptr);
  }

  ServerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerMessage& from);
  void MergeFrom(const ServerMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "naki3d.common.protocol.ServerMessage";
  }
  protected:
  explicit ServerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wrappers_2eproto);
    return ::descriptor_table_wrappers_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionIdFieldNumber = 1,
    kEncryptionInfoFieldNumber = 16,
    kLoadPackageFieldNumber = 17,
    kClearPackageFieldNumber = 18,
  };
  // string connection_id = 1;
  void clear_connection_id();
  const std::string& connection_id() const;
  void set_connection_id(const std::string& value);
  void set_connection_id(std::string&& value);
  void set_connection_id(const char* value);
  void set_connection_id(const char* value, size_t size);
  std::string* mutable_connection_id();
  std::string* release_connection_id();
  void set_allocated_connection_id(std::string* connection_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_connection_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_connection_id(
      std::string* connection_id);
  private:
  const std::string& _internal_connection_id() const;
  void _internal_set_connection_id(const std::string& value);
  std::string* _internal_mutable_connection_id();
  public:

  // .naki3d.common.protocol.EncryptionInfo encryption_info = 16;
  bool has_encryption_info() const;
  private:
  bool _internal_has_encryption_info() const;
  public:
  void clear_encryption_info();
  const ::naki3d::common::protocol::EncryptionInfo& encryption_info() const;
  ::naki3d::common::protocol::EncryptionInfo* release_encryption_info();
  ::naki3d::common::protocol::EncryptionInfo* mutable_encryption_info();
  void set_allocated_encryption_info(::naki3d::common::protocol::EncryptionInfo* encryption_info);
  private:
  const ::naki3d::common::protocol::EncryptionInfo& _internal_encryption_info() const;
  ::naki3d::common::protocol::EncryptionInfo* _internal_mutable_encryption_info();
  public:
  void unsafe_arena_set_allocated_encryption_info(
      ::naki3d::common::protocol::EncryptionInfo* encryption_info);
  ::naki3d::common::protocol::EncryptionInfo* unsafe_arena_release_encryption_info();

  // .naki3d.common.protocol.LoadPackage load_package = 17;
  bool has_load_package() const;
  private:
  bool _internal_has_load_package() const;
  public:
  void clear_load_package();
  const ::naki3d::common::protocol::LoadPackage& load_package() const;
  ::naki3d::common::protocol::LoadPackage* release_load_package();
  ::naki3d::common::protocol::LoadPackage* mutable_load_package();
  void set_allocated_load_package(::naki3d::common::protocol::LoadPackage* load_package);
  private:
  const ::naki3d::common::protocol::LoadPackage& _internal_load_package() const;
  ::naki3d::common::protocol::LoadPackage* _internal_mutable_load_package();
  public:
  void unsafe_arena_set_allocated_load_package(
      ::naki3d::common::protocol::LoadPackage* load_package);
  ::naki3d::common::protocol::LoadPackage* unsafe_arena_release_load_package();

  // .naki3d.common.protocol.ClearPackage clear_package = 18;
  bool has_clear_package() const;
  private:
  bool _internal_has_clear_package() const;
  public:
  void clear_clear_package();
  const ::naki3d::common::protocol::ClearPackage& clear_package() const;
  ::naki3d::common::protocol::ClearPackage* release_clear_package();
  ::naki3d::common::protocol::ClearPackage* mutable_clear_package();
  void set_allocated_clear_package(::naki3d::common::protocol::ClearPackage* clear_package);
  private:
  const ::naki3d::common::protocol::ClearPackage& _internal_clear_package() const;
  ::naki3d::common::protocol::ClearPackage* _internal_mutable_clear_package();
  public:
  void unsafe_arena_set_allocated_clear_package(
      ::naki3d::common::protocol::ClearPackage* clear_package);
  ::naki3d::common::protocol::ClearPackage* unsafe_arena_release_clear_package();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:naki3d.common.protocol.ServerMessage)
 private:
  class _Internal;
  void set_has_encryption_info();
  void set_has_load_package();
  void set_has_clear_package();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connection_id_;
  union MessageUnion {
    MessageUnion() {}
    ::naki3d::common::protocol::EncryptionInfo* encryption_info_;
    ::naki3d::common::protocol::LoadPackage* load_package_;
    ::naki3d::common::protocol::ClearPackage* clear_package_;
  } message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_wrappers_2eproto;
};
// -------------------------------------------------------------------

class DeviceMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:naki3d.common.protocol.DeviceMessage) */ {
 public:
  inline DeviceMessage() : DeviceMessage(nullptr) {};
  virtual ~DeviceMessage();

  DeviceMessage(const DeviceMessage& from);
  DeviceMessage(DeviceMessage&& from) noexcept
    : DeviceMessage() {
    *this = ::std::move(from);
  }

  inline DeviceMessage& operator=(const DeviceMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceMessage& operator=(DeviceMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeviceMessage& default_instance();

  enum MessageCase {
    kDeviceDescriptor = 16,
    kPing = 17,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceMessage* internal_default_instance() {
    return reinterpret_cast<const DeviceMessage*>(
               &_DeviceMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeviceMessage& a, DeviceMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceMessage* New() const final {
    return CreateMaybeMessage<DeviceMessage>(nullptr);
  }

  DeviceMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeviceMessage& from);
  void MergeFrom(const DeviceMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "naki3d.common.protocol.DeviceMessage";
  }
  protected:
  explicit DeviceMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wrappers_2eproto);
    return ::descriptor_table_wrappers_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionIdFieldNumber = 1,
    kDeviceDescriptorFieldNumber = 16,
    kPingFieldNumber = 17,
  };
  // string connection_id = 1;
  void clear_connection_id();
  const std::string& connection_id() const;
  void set_connection_id(const std::string& value);
  void set_connection_id(std::string&& value);
  void set_connection_id(const char* value);
  void set_connection_id(const char* value, size_t size);
  std::string* mutable_connection_id();
  std::string* release_connection_id();
  void set_allocated_connection_id(std::string* connection_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_connection_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_connection_id(
      std::string* connection_id);
  private:
  const std::string& _internal_connection_id() const;
  void _internal_set_connection_id(const std::string& value);
  std::string* _internal_mutable_connection_id();
  public:

  // .naki3d.common.protocol.DeviceDescriptor device_descriptor = 16;
  bool has_device_descriptor() const;
  private:
  bool _internal_has_device_descriptor() const;
  public:
  void clear_device_descriptor();
  const ::naki3d::common::protocol::DeviceDescriptor& device_descriptor() const;
  ::naki3d::common::protocol::DeviceDescriptor* release_device_descriptor();
  ::naki3d::common::protocol::DeviceDescriptor* mutable_device_descriptor();
  void set_allocated_device_descriptor(::naki3d::common::protocol::DeviceDescriptor* device_descriptor);
  private:
  const ::naki3d::common::protocol::DeviceDescriptor& _internal_device_descriptor() const;
  ::naki3d::common::protocol::DeviceDescriptor* _internal_mutable_device_descriptor();
  public:
  void unsafe_arena_set_allocated_device_descriptor(
      ::naki3d::common::protocol::DeviceDescriptor* device_descriptor);
  ::naki3d::common::protocol::DeviceDescriptor* unsafe_arena_release_device_descriptor();

  // .naki3d.common.protocol.Ping ping = 17;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;
  public:
  void clear_ping();
  const ::naki3d::common::protocol::Ping& ping() const;
  ::naki3d::common::protocol::Ping* release_ping();
  ::naki3d::common::protocol::Ping* mutable_ping();
  void set_allocated_ping(::naki3d::common::protocol::Ping* ping);
  private:
  const ::naki3d::common::protocol::Ping& _internal_ping() const;
  ::naki3d::common::protocol::Ping* _internal_mutable_ping();
  public:
  void unsafe_arena_set_allocated_ping(
      ::naki3d::common::protocol::Ping* ping);
  ::naki3d::common::protocol::Ping* unsafe_arena_release_ping();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:naki3d.common.protocol.DeviceMessage)
 private:
  class _Internal;
  void set_has_device_descriptor();
  void set_has_ping();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connection_id_;
  union MessageUnion {
    MessageUnion() {}
    ::naki3d::common::protocol::DeviceDescriptor* device_descriptor_;
    ::naki3d::common::protocol::Ping* ping_;
  } message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_wrappers_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:naki3d.common.protocol.SensorMessage) */ {
 public:
  inline SensorMessage() : SensorMessage(nullptr) {};
  virtual ~SensorMessage();

  SensorMessage(const SensorMessage& from);
  SensorMessage(SensorMessage&& from) noexcept
    : SensorMessage() {
    *this = ::std::move(from);
  }

  inline SensorMessage& operator=(const SensorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMessage& operator=(SensorMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorMessage& default_instance();

  enum DataCase {
    kHandTracking = 15,
    kGesture = 16,
    kHandMovement = 17,
    kBestUserChanged = 18,
    kKeyboardUpdate = 19,
    kMouseMove = 20,
    kMouseButton = 21,
    kMouseScroll = 22,
    kUltrasonicDistance = 23,
    kLightLevel = 24,
    kEvent = 25,
    kPirMovement = 26,
    DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorMessage* internal_default_instance() {
    return reinterpret_cast<const SensorMessage*>(
               &_SensorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SensorMessage& a, SensorMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorMessage* New() const final {
    return CreateMaybeMessage<SensorMessage>(nullptr);
  }

  SensorMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorMessage& from);
  void MergeFrom(const SensorMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "naki3d.common.protocol.SensorMessage";
  }
  protected:
  explicit SensorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wrappers_2eproto);
    return ::descriptor_table_wrappers_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorIdFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kHandTrackingFieldNumber = 15,
    kGestureFieldNumber = 16,
    kHandMovementFieldNumber = 17,
    kBestUserChangedFieldNumber = 18,
    kKeyboardUpdateFieldNumber = 19,
    kMouseMoveFieldNumber = 20,
    kMouseButtonFieldNumber = 21,
    kMouseScrollFieldNumber = 22,
    kUltrasonicDistanceFieldNumber = 23,
    kLightLevelFieldNumber = 24,
    kEventFieldNumber = 25,
    kPirMovementFieldNumber = 26,
  };
  // string sensor_id = 1;
  void clear_sensor_id();
  const std::string& sensor_id() const;
  void set_sensor_id(const std::string& value);
  void set_sensor_id(std::string&& value);
  void set_sensor_id(const char* value);
  void set_sensor_id(const char* value, size_t size);
  std::string* mutable_sensor_id();
  std::string* release_sensor_id();
  void set_allocated_sensor_id(std::string* sensor_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_sensor_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sensor_id(
      std::string* sensor_id);
  private:
  const std::string& _internal_sensor_id() const;
  void _internal_set_sensor_id(const std::string& value);
  std::string* _internal_mutable_sensor_id();
  public:

  // uint64 timestamp = 2;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .naki3d.common.protocol.MediapipeHandTrackingData handTracking = 15;
  bool has_handtracking() const;
  private:
  bool _internal_has_handtracking() const;
  public:
  void clear_handtracking();
  const ::naki3d::common::protocol::MediapipeHandTrackingData& handtracking() const;
  ::naki3d::common::protocol::MediapipeHandTrackingData* release_handtracking();
  ::naki3d::common::protocol::MediapipeHandTrackingData* mutable_handtracking();
  void set_allocated_handtracking(::naki3d::common::protocol::MediapipeHandTrackingData* handtracking);
  private:
  const ::naki3d::common::protocol::MediapipeHandTrackingData& _internal_handtracking() const;
  ::naki3d::common::protocol::MediapipeHandTrackingData* _internal_mutable_handtracking();
  public:
  void unsafe_arena_set_allocated_handtracking(
      ::naki3d::common::protocol::MediapipeHandTrackingData* handtracking);
  ::naki3d::common::protocol::MediapipeHandTrackingData* unsafe_arena_release_handtracking();

  // .naki3d.common.protocol.GestureData gesture = 16;
  bool has_gesture() const;
  private:
  bool _internal_has_gesture() const;
  public:
  void clear_gesture();
  const ::naki3d::common::protocol::GestureData& gesture() const;
  ::naki3d::common::protocol::GestureData* release_gesture();
  ::naki3d::common::protocol::GestureData* mutable_gesture();
  void set_allocated_gesture(::naki3d::common::protocol::GestureData* gesture);
  private:
  const ::naki3d::common::protocol::GestureData& _internal_gesture() const;
  ::naki3d::common::protocol::GestureData* _internal_mutable_gesture();
  public:
  void unsafe_arena_set_allocated_gesture(
      ::naki3d::common::protocol::GestureData* gesture);
  ::naki3d::common::protocol::GestureData* unsafe_arena_release_gesture();

  // .naki3d.common.protocol.HandMovementData hand_movement = 17;
  bool has_hand_movement() const;
  private:
  bool _internal_has_hand_movement() const;
  public:
  void clear_hand_movement();
  const ::naki3d::common::protocol::HandMovementData& hand_movement() const;
  ::naki3d::common::protocol::HandMovementData* release_hand_movement();
  ::naki3d::common::protocol::HandMovementData* mutable_hand_movement();
  void set_allocated_hand_movement(::naki3d::common::protocol::HandMovementData* hand_movement);
  private:
  const ::naki3d::common::protocol::HandMovementData& _internal_hand_movement() const;
  ::naki3d::common::protocol::HandMovementData* _internal_mutable_hand_movement();
  public:
  void unsafe_arena_set_allocated_hand_movement(
      ::naki3d::common::protocol::HandMovementData* hand_movement);
  ::naki3d::common::protocol::HandMovementData* unsafe_arena_release_hand_movement();

  // .naki3d.common.protocol.BestUserChangedData best_user_changed = 18;
  bool has_best_user_changed() const;
  private:
  bool _internal_has_best_user_changed() const;
  public:
  void clear_best_user_changed();
  const ::naki3d::common::protocol::BestUserChangedData& best_user_changed() const;
  ::naki3d::common::protocol::BestUserChangedData* release_best_user_changed();
  ::naki3d::common::protocol::BestUserChangedData* mutable_best_user_changed();
  void set_allocated_best_user_changed(::naki3d::common::protocol::BestUserChangedData* best_user_changed);
  private:
  const ::naki3d::common::protocol::BestUserChangedData& _internal_best_user_changed() const;
  ::naki3d::common::protocol::BestUserChangedData* _internal_mutable_best_user_changed();
  public:
  void unsafe_arena_set_allocated_best_user_changed(
      ::naki3d::common::protocol::BestUserChangedData* best_user_changed);
  ::naki3d::common::protocol::BestUserChangedData* unsafe_arena_release_best_user_changed();

  // .naki3d.common.protocol.KeyboardUpdateData keyboard_update = 19;
  bool has_keyboard_update() const;
  private:
  bool _internal_has_keyboard_update() const;
  public:
  void clear_keyboard_update();
  const ::naki3d::common::protocol::KeyboardUpdateData& keyboard_update() const;
  ::naki3d::common::protocol::KeyboardUpdateData* release_keyboard_update();
  ::naki3d::common::protocol::KeyboardUpdateData* mutable_keyboard_update();
  void set_allocated_keyboard_update(::naki3d::common::protocol::KeyboardUpdateData* keyboard_update);
  private:
  const ::naki3d::common::protocol::KeyboardUpdateData& _internal_keyboard_update() const;
  ::naki3d::common::protocol::KeyboardUpdateData* _internal_mutable_keyboard_update();
  public:
  void unsafe_arena_set_allocated_keyboard_update(
      ::naki3d::common::protocol::KeyboardUpdateData* keyboard_update);
  ::naki3d::common::protocol::KeyboardUpdateData* unsafe_arena_release_keyboard_update();

  // .naki3d.common.protocol.MouseMoveData mouse_move = 20;
  bool has_mouse_move() const;
  private:
  bool _internal_has_mouse_move() const;
  public:
  void clear_mouse_move();
  const ::naki3d::common::protocol::MouseMoveData& mouse_move() const;
  ::naki3d::common::protocol::MouseMoveData* release_mouse_move();
  ::naki3d::common::protocol::MouseMoveData* mutable_mouse_move();
  void set_allocated_mouse_move(::naki3d::common::protocol::MouseMoveData* mouse_move);
  private:
  const ::naki3d::common::protocol::MouseMoveData& _internal_mouse_move() const;
  ::naki3d::common::protocol::MouseMoveData* _internal_mutable_mouse_move();
  public:
  void unsafe_arena_set_allocated_mouse_move(
      ::naki3d::common::protocol::MouseMoveData* mouse_move);
  ::naki3d::common::protocol::MouseMoveData* unsafe_arena_release_mouse_move();

  // .naki3d.common.protocol.MouseButtonData mouse_button = 21;
  bool has_mouse_button() const;
  private:
  bool _internal_has_mouse_button() const;
  public:
  void clear_mouse_button();
  const ::naki3d::common::protocol::MouseButtonData& mouse_button() const;
  ::naki3d::common::protocol::MouseButtonData* release_mouse_button();
  ::naki3d::common::protocol::MouseButtonData* mutable_mouse_button();
  void set_allocated_mouse_button(::naki3d::common::protocol::MouseButtonData* mouse_button);
  private:
  const ::naki3d::common::protocol::MouseButtonData& _internal_mouse_button() const;
  ::naki3d::common::protocol::MouseButtonData* _internal_mutable_mouse_button();
  public:
  void unsafe_arena_set_allocated_mouse_button(
      ::naki3d::common::protocol::MouseButtonData* mouse_button);
  ::naki3d::common::protocol::MouseButtonData* unsafe_arena_release_mouse_button();

  // .naki3d.common.protocol.MouseScrollData mouse_scroll = 22;
  bool has_mouse_scroll() const;
  private:
  bool _internal_has_mouse_scroll() const;
  public:
  void clear_mouse_scroll();
  const ::naki3d::common::protocol::MouseScrollData& mouse_scroll() const;
  ::naki3d::common::protocol::MouseScrollData* release_mouse_scroll();
  ::naki3d::common::protocol::MouseScrollData* mutable_mouse_scroll();
  void set_allocated_mouse_scroll(::naki3d::common::protocol::MouseScrollData* mouse_scroll);
  private:
  const ::naki3d::common::protocol::MouseScrollData& _internal_mouse_scroll() const;
  ::naki3d::common::protocol::MouseScrollData* _internal_mutable_mouse_scroll();
  public:
  void unsafe_arena_set_allocated_mouse_scroll(
      ::naki3d::common::protocol::MouseScrollData* mouse_scroll);
  ::naki3d::common::protocol::MouseScrollData* unsafe_arena_release_mouse_scroll();

  // .naki3d.common.protocol.UltrasonicDistanceData ultrasonic_distance = 23;
  bool has_ultrasonic_distance() const;
  private:
  bool _internal_has_ultrasonic_distance() const;
  public:
  void clear_ultrasonic_distance();
  const ::naki3d::common::protocol::UltrasonicDistanceData& ultrasonic_distance() const;
  ::naki3d::common::protocol::UltrasonicDistanceData* release_ultrasonic_distance();
  ::naki3d::common::protocol::UltrasonicDistanceData* mutable_ultrasonic_distance();
  void set_allocated_ultrasonic_distance(::naki3d::common::protocol::UltrasonicDistanceData* ultrasonic_distance);
  private:
  const ::naki3d::common::protocol::UltrasonicDistanceData& _internal_ultrasonic_distance() const;
  ::naki3d::common::protocol::UltrasonicDistanceData* _internal_mutable_ultrasonic_distance();
  public:
  void unsafe_arena_set_allocated_ultrasonic_distance(
      ::naki3d::common::protocol::UltrasonicDistanceData* ultrasonic_distance);
  ::naki3d::common::protocol::UltrasonicDistanceData* unsafe_arena_release_ultrasonic_distance();

  // .naki3d.common.protocol.LightLevelData light_level = 24;
  bool has_light_level() const;
  private:
  bool _internal_has_light_level() const;
  public:
  void clear_light_level();
  const ::naki3d::common::protocol::LightLevelData& light_level() const;
  ::naki3d::common::protocol::LightLevelData* release_light_level();
  ::naki3d::common::protocol::LightLevelData* mutable_light_level();
  void set_allocated_light_level(::naki3d::common::protocol::LightLevelData* light_level);
  private:
  const ::naki3d::common::protocol::LightLevelData& _internal_light_level() const;
  ::naki3d::common::protocol::LightLevelData* _internal_mutable_light_level();
  public:
  void unsafe_arena_set_allocated_light_level(
      ::naki3d::common::protocol::LightLevelData* light_level);
  ::naki3d::common::protocol::LightLevelData* unsafe_arena_release_light_level();

  // .naki3d.common.protocol.EventData event = 25;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::naki3d::common::protocol::EventData& event() const;
  ::naki3d::common::protocol::EventData* release_event();
  ::naki3d::common::protocol::EventData* mutable_event();
  void set_allocated_event(::naki3d::common::protocol::EventData* event);
  private:
  const ::naki3d::common::protocol::EventData& _internal_event() const;
  ::naki3d::common::protocol::EventData* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::naki3d::common::protocol::EventData* event);
  ::naki3d::common::protocol::EventData* unsafe_arena_release_event();

  // .naki3d.common.protocol.PirMovementData pir_movement = 26;
  bool has_pir_movement() const;
  private:
  bool _internal_has_pir_movement() const;
  public:
  void clear_pir_movement();
  const ::naki3d::common::protocol::PirMovementData& pir_movement() const;
  ::naki3d::common::protocol::PirMovementData* release_pir_movement();
  ::naki3d::common::protocol::PirMovementData* mutable_pir_movement();
  void set_allocated_pir_movement(::naki3d::common::protocol::PirMovementData* pir_movement);
  private:
  const ::naki3d::common::protocol::PirMovementData& _internal_pir_movement() const;
  ::naki3d::common::protocol::PirMovementData* _internal_mutable_pir_movement();
  public:
  void unsafe_arena_set_allocated_pir_movement(
      ::naki3d::common::protocol::PirMovementData* pir_movement);
  ::naki3d::common::protocol::PirMovementData* unsafe_arena_release_pir_movement();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:naki3d.common.protocol.SensorMessage)
 private:
  class _Internal;
  void set_has_handtracking();
  void set_has_gesture();
  void set_has_hand_movement();
  void set_has_best_user_changed();
  void set_has_keyboard_update();
  void set_has_mouse_move();
  void set_has_mouse_button();
  void set_has_mouse_scroll();
  void set_has_ultrasonic_distance();
  void set_has_light_level();
  void set_has_event();
  void set_has_pir_movement();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensor_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  union DataUnion {
    DataUnion() {}
    ::naki3d::common::protocol::MediapipeHandTrackingData* handtracking_;
    ::naki3d::common::protocol::GestureData* gesture_;
    ::naki3d::common::protocol::HandMovementData* hand_movement_;
    ::naki3d::common::protocol::BestUserChangedData* best_user_changed_;
    ::naki3d::common::protocol::KeyboardUpdateData* keyboard_update_;
    ::naki3d::common::protocol::MouseMoveData* mouse_move_;
    ::naki3d::common::protocol::MouseButtonData* mouse_button_;
    ::naki3d::common::protocol::MouseScrollData* mouse_scroll_;
    ::naki3d::common::protocol::UltrasonicDistanceData* ultrasonic_distance_;
    ::naki3d::common::protocol::LightLevelData* light_level_;
    ::naki3d::common::protocol::EventData* event_;
    ::naki3d::common::protocol::PirMovementData* pir_movement_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_wrappers_2eproto;
};
// -------------------------------------------------------------------

class SensorControlMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:naki3d.common.protocol.SensorControlMessage) */ {
 public:
  inline SensorControlMessage() : SensorControlMessage(nullptr) {};
  virtual ~SensorControlMessage();

  SensorControlMessage(const SensorControlMessage& from);
  SensorControlMessage(SensorControlMessage&& from) noexcept
    : SensorControlMessage() {
    *this = ::std::move(from);
  }

  inline SensorControlMessage& operator=(const SensorControlMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorControlMessage& operator=(SensorControlMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorControlMessage& default_instance();

  enum MessageCase {
    kSensorList = 16,
    kCecMessage = 17,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorControlMessage* internal_default_instance() {
    return reinterpret_cast<const SensorControlMessage*>(
               &_SensorControlMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SensorControlMessage& a, SensorControlMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorControlMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorControlMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorControlMessage* New() const final {
    return CreateMaybeMessage<SensorControlMessage>(nullptr);
  }

  SensorControlMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorControlMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorControlMessage& from);
  void MergeFrom(const SensorControlMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorControlMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "naki3d.common.protocol.SensorControlMessage";
  }
  protected:
  explicit SensorControlMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_wrappers_2eproto);
    return ::descriptor_table_wrappers_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostnameFieldNumber = 1,
    kSensorListFieldNumber = 16,
    kCecMessageFieldNumber = 17,
  };
  // string hostname = 1;
  void clear_hostname();
  const std::string& hostname() const;
  void set_hostname(const std::string& value);
  void set_hostname(std::string&& value);
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  std::string* mutable_hostname();
  std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_hostname();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hostname(
      std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // .naki3d.common.protocol.SensorListRequest sensor_list = 16;
  bool has_sensor_list() const;
  private:
  bool _internal_has_sensor_list() const;
  public:
  void clear_sensor_list();
  const ::naki3d::common::protocol::SensorListRequest& sensor_list() const;
  ::naki3d::common::protocol::SensorListRequest* release_sensor_list();
  ::naki3d::common::protocol::SensorListRequest* mutable_sensor_list();
  void set_allocated_sensor_list(::naki3d::common::protocol::SensorListRequest* sensor_list);
  private:
  const ::naki3d::common::protocol::SensorListRequest& _internal_sensor_list() const;
  ::naki3d::common::protocol::SensorListRequest* _internal_mutable_sensor_list();
  public:
  void unsafe_arena_set_allocated_sensor_list(
      ::naki3d::common::protocol::SensorListRequest* sensor_list);
  ::naki3d::common::protocol::SensorListRequest* unsafe_arena_release_sensor_list();

  // .naki3d.common.protocol.CECMessage cec_message = 17;
  bool has_cec_message() const;
  private:
  bool _internal_has_cec_message() const;
  public:
  void clear_cec_message();
  const ::naki3d::common::protocol::CECMessage& cec_message() const;
  ::naki3d::common::protocol::CECMessage* release_cec_message();
  ::naki3d::common::protocol::CECMessage* mutable_cec_message();
  void set_allocated_cec_message(::naki3d::common::protocol::CECMessage* cec_message);
  private:
  const ::naki3d::common::protocol::CECMessage& _internal_cec_message() const;
  ::naki3d::common::protocol::CECMessage* _internal_mutable_cec_message();
  public:
  void unsafe_arena_set_allocated_cec_message(
      ::naki3d::common::protocol::CECMessage* cec_message);
  ::naki3d::common::protocol::CECMessage* unsafe_arena_release_cec_message();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:naki3d.common.protocol.SensorControlMessage)
 private:
  class _Internal;
  void set_has_sensor_list();
  void set_has_cec_message();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  union MessageUnion {
    MessageUnion() {}
    ::naki3d::common::protocol::SensorListRequest* sensor_list_;
    ::naki3d::common::protocol::CECMessage* cec_message_;
  } message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_wrappers_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServerMessage

// string connection_id = 1;
inline void ServerMessage::clear_connection_id() {
  connection_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ServerMessage::connection_id() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.ServerMessage.connection_id)
  return _internal_connection_id();
}
inline void ServerMessage::set_connection_id(const std::string& value) {
  _internal_set_connection_id(value);
  // @@protoc_insertion_point(field_set:naki3d.common.protocol.ServerMessage.connection_id)
}
inline std::string* ServerMessage::mutable_connection_id() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.ServerMessage.connection_id)
  return _internal_mutable_connection_id();
}
inline const std::string& ServerMessage::_internal_connection_id() const {
  return connection_id_.Get();
}
inline void ServerMessage::_internal_set_connection_id(const std::string& value) {
  
  connection_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServerMessage::set_connection_id(std::string&& value) {
  
  connection_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:naki3d.common.protocol.ServerMessage.connection_id)
}
inline void ServerMessage::set_connection_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  connection_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:naki3d.common.protocol.ServerMessage.connection_id)
}
inline void ServerMessage::set_connection_id(const char* value,
    size_t size) {
  
  connection_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:naki3d.common.protocol.ServerMessage.connection_id)
}
inline std::string* ServerMessage::_internal_mutable_connection_id() {
  
  return connection_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServerMessage::release_connection_id() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.ServerMessage.connection_id)
  return connection_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServerMessage::set_allocated_connection_id(std::string* connection_id) {
  if (connection_id != nullptr) {
    
  } else {
    
  }
  connection_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), connection_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:naki3d.common.protocol.ServerMessage.connection_id)
}
inline std::string* ServerMessage::unsafe_arena_release_connection_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.ServerMessage.connection_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return connection_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ServerMessage::unsafe_arena_set_allocated_connection_id(
    std::string* connection_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (connection_id != nullptr) {
    
  } else {
    
  }
  connection_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      connection_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.ServerMessage.connection_id)
}

// .naki3d.common.protocol.EncryptionInfo encryption_info = 16;
inline bool ServerMessage::_internal_has_encryption_info() const {
  return message_case() == kEncryptionInfo;
}
inline bool ServerMessage::has_encryption_info() const {
  return _internal_has_encryption_info();
}
inline void ServerMessage::set_has_encryption_info() {
  _oneof_case_[0] = kEncryptionInfo;
}
inline ::naki3d::common::protocol::EncryptionInfo* ServerMessage::release_encryption_info() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.ServerMessage.encryption_info)
  if (_internal_has_encryption_info()) {
    clear_has_message();
      ::naki3d::common::protocol::EncryptionInfo* temp = message_.encryption_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.encryption_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::EncryptionInfo& ServerMessage::_internal_encryption_info() const {
  return _internal_has_encryption_info()
      ? *message_.encryption_info_
      : *reinterpret_cast< ::naki3d::common::protocol::EncryptionInfo*>(&::naki3d::common::protocol::_EncryptionInfo_default_instance_);
}
inline const ::naki3d::common::protocol::EncryptionInfo& ServerMessage::encryption_info() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.ServerMessage.encryption_info)
  return _internal_encryption_info();
}
inline ::naki3d::common::protocol::EncryptionInfo* ServerMessage::unsafe_arena_release_encryption_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.ServerMessage.encryption_info)
  if (_internal_has_encryption_info()) {
    clear_has_message();
    ::naki3d::common::protocol::EncryptionInfo* temp = message_.encryption_info_;
    message_.encryption_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_encryption_info(::naki3d::common::protocol::EncryptionInfo* encryption_info) {
  clear_message();
  if (encryption_info) {
    set_has_encryption_info();
    message_.encryption_info_ = encryption_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.ServerMessage.encryption_info)
}
inline ::naki3d::common::protocol::EncryptionInfo* ServerMessage::_internal_mutable_encryption_info() {
  if (!_internal_has_encryption_info()) {
    clear_message();
    set_has_encryption_info();
    message_.encryption_info_ = CreateMaybeMessage< ::naki3d::common::protocol::EncryptionInfo >(GetArena());
  }
  return message_.encryption_info_;
}
inline ::naki3d::common::protocol::EncryptionInfo* ServerMessage::mutable_encryption_info() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.ServerMessage.encryption_info)
  return _internal_mutable_encryption_info();
}

// .naki3d.common.protocol.LoadPackage load_package = 17;
inline bool ServerMessage::_internal_has_load_package() const {
  return message_case() == kLoadPackage;
}
inline bool ServerMessage::has_load_package() const {
  return _internal_has_load_package();
}
inline void ServerMessage::set_has_load_package() {
  _oneof_case_[0] = kLoadPackage;
}
inline ::naki3d::common::protocol::LoadPackage* ServerMessage::release_load_package() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.ServerMessage.load_package)
  if (_internal_has_load_package()) {
    clear_has_message();
      ::naki3d::common::protocol::LoadPackage* temp = message_.load_package_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.load_package_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::LoadPackage& ServerMessage::_internal_load_package() const {
  return _internal_has_load_package()
      ? *message_.load_package_
      : *reinterpret_cast< ::naki3d::common::protocol::LoadPackage*>(&::naki3d::common::protocol::_LoadPackage_default_instance_);
}
inline const ::naki3d::common::protocol::LoadPackage& ServerMessage::load_package() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.ServerMessage.load_package)
  return _internal_load_package();
}
inline ::naki3d::common::protocol::LoadPackage* ServerMessage::unsafe_arena_release_load_package() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.ServerMessage.load_package)
  if (_internal_has_load_package()) {
    clear_has_message();
    ::naki3d::common::protocol::LoadPackage* temp = message_.load_package_;
    message_.load_package_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_load_package(::naki3d::common::protocol::LoadPackage* load_package) {
  clear_message();
  if (load_package) {
    set_has_load_package();
    message_.load_package_ = load_package;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.ServerMessage.load_package)
}
inline ::naki3d::common::protocol::LoadPackage* ServerMessage::_internal_mutable_load_package() {
  if (!_internal_has_load_package()) {
    clear_message();
    set_has_load_package();
    message_.load_package_ = CreateMaybeMessage< ::naki3d::common::protocol::LoadPackage >(GetArena());
  }
  return message_.load_package_;
}
inline ::naki3d::common::protocol::LoadPackage* ServerMessage::mutable_load_package() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.ServerMessage.load_package)
  return _internal_mutable_load_package();
}

// .naki3d.common.protocol.ClearPackage clear_package = 18;
inline bool ServerMessage::_internal_has_clear_package() const {
  return message_case() == kClearPackage;
}
inline bool ServerMessage::has_clear_package() const {
  return _internal_has_clear_package();
}
inline void ServerMessage::set_has_clear_package() {
  _oneof_case_[0] = kClearPackage;
}
inline ::naki3d::common::protocol::ClearPackage* ServerMessage::release_clear_package() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.ServerMessage.clear_package)
  if (_internal_has_clear_package()) {
    clear_has_message();
      ::naki3d::common::protocol::ClearPackage* temp = message_.clear_package_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.clear_package_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::ClearPackage& ServerMessage::_internal_clear_package() const {
  return _internal_has_clear_package()
      ? *message_.clear_package_
      : *reinterpret_cast< ::naki3d::common::protocol::ClearPackage*>(&::naki3d::common::protocol::_ClearPackage_default_instance_);
}
inline const ::naki3d::common::protocol::ClearPackage& ServerMessage::clear_package() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.ServerMessage.clear_package)
  return _internal_clear_package();
}
inline ::naki3d::common::protocol::ClearPackage* ServerMessage::unsafe_arena_release_clear_package() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.ServerMessage.clear_package)
  if (_internal_has_clear_package()) {
    clear_has_message();
    ::naki3d::common::protocol::ClearPackage* temp = message_.clear_package_;
    message_.clear_package_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_clear_package(::naki3d::common::protocol::ClearPackage* clear_package) {
  clear_message();
  if (clear_package) {
    set_has_clear_package();
    message_.clear_package_ = clear_package;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.ServerMessage.clear_package)
}
inline ::naki3d::common::protocol::ClearPackage* ServerMessage::_internal_mutable_clear_package() {
  if (!_internal_has_clear_package()) {
    clear_message();
    set_has_clear_package();
    message_.clear_package_ = CreateMaybeMessage< ::naki3d::common::protocol::ClearPackage >(GetArena());
  }
  return message_.clear_package_;
}
inline ::naki3d::common::protocol::ClearPackage* ServerMessage::mutable_clear_package() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.ServerMessage.clear_package)
  return _internal_mutable_clear_package();
}

inline bool ServerMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void ServerMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline ServerMessage::MessageCase ServerMessage::message_case() const {
  return ServerMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DeviceMessage

// string connection_id = 1;
inline void DeviceMessage::clear_connection_id() {
  connection_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DeviceMessage::connection_id() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.DeviceMessage.connection_id)
  return _internal_connection_id();
}
inline void DeviceMessage::set_connection_id(const std::string& value) {
  _internal_set_connection_id(value);
  // @@protoc_insertion_point(field_set:naki3d.common.protocol.DeviceMessage.connection_id)
}
inline std::string* DeviceMessage::mutable_connection_id() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.DeviceMessage.connection_id)
  return _internal_mutable_connection_id();
}
inline const std::string& DeviceMessage::_internal_connection_id() const {
  return connection_id_.Get();
}
inline void DeviceMessage::_internal_set_connection_id(const std::string& value) {
  
  connection_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DeviceMessage::set_connection_id(std::string&& value) {
  
  connection_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:naki3d.common.protocol.DeviceMessage.connection_id)
}
inline void DeviceMessage::set_connection_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  connection_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:naki3d.common.protocol.DeviceMessage.connection_id)
}
inline void DeviceMessage::set_connection_id(const char* value,
    size_t size) {
  
  connection_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:naki3d.common.protocol.DeviceMessage.connection_id)
}
inline std::string* DeviceMessage::_internal_mutable_connection_id() {
  
  return connection_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DeviceMessage::release_connection_id() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.DeviceMessage.connection_id)
  return connection_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DeviceMessage::set_allocated_connection_id(std::string* connection_id) {
  if (connection_id != nullptr) {
    
  } else {
    
  }
  connection_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), connection_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:naki3d.common.protocol.DeviceMessage.connection_id)
}
inline std::string* DeviceMessage::unsafe_arena_release_connection_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.DeviceMessage.connection_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return connection_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DeviceMessage::unsafe_arena_set_allocated_connection_id(
    std::string* connection_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (connection_id != nullptr) {
    
  } else {
    
  }
  connection_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      connection_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.DeviceMessage.connection_id)
}

// .naki3d.common.protocol.DeviceDescriptor device_descriptor = 16;
inline bool DeviceMessage::_internal_has_device_descriptor() const {
  return message_case() == kDeviceDescriptor;
}
inline bool DeviceMessage::has_device_descriptor() const {
  return _internal_has_device_descriptor();
}
inline void DeviceMessage::set_has_device_descriptor() {
  _oneof_case_[0] = kDeviceDescriptor;
}
inline ::naki3d::common::protocol::DeviceDescriptor* DeviceMessage::release_device_descriptor() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.DeviceMessage.device_descriptor)
  if (_internal_has_device_descriptor()) {
    clear_has_message();
      ::naki3d::common::protocol::DeviceDescriptor* temp = message_.device_descriptor_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.device_descriptor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::DeviceDescriptor& DeviceMessage::_internal_device_descriptor() const {
  return _internal_has_device_descriptor()
      ? *message_.device_descriptor_
      : *reinterpret_cast< ::naki3d::common::protocol::DeviceDescriptor*>(&::naki3d::common::protocol::_DeviceDescriptor_default_instance_);
}
inline const ::naki3d::common::protocol::DeviceDescriptor& DeviceMessage::device_descriptor() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.DeviceMessage.device_descriptor)
  return _internal_device_descriptor();
}
inline ::naki3d::common::protocol::DeviceDescriptor* DeviceMessage::unsafe_arena_release_device_descriptor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.DeviceMessage.device_descriptor)
  if (_internal_has_device_descriptor()) {
    clear_has_message();
    ::naki3d::common::protocol::DeviceDescriptor* temp = message_.device_descriptor_;
    message_.device_descriptor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DeviceMessage::unsafe_arena_set_allocated_device_descriptor(::naki3d::common::protocol::DeviceDescriptor* device_descriptor) {
  clear_message();
  if (device_descriptor) {
    set_has_device_descriptor();
    message_.device_descriptor_ = device_descriptor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.DeviceMessage.device_descriptor)
}
inline ::naki3d::common::protocol::DeviceDescriptor* DeviceMessage::_internal_mutable_device_descriptor() {
  if (!_internal_has_device_descriptor()) {
    clear_message();
    set_has_device_descriptor();
    message_.device_descriptor_ = CreateMaybeMessage< ::naki3d::common::protocol::DeviceDescriptor >(GetArena());
  }
  return message_.device_descriptor_;
}
inline ::naki3d::common::protocol::DeviceDescriptor* DeviceMessage::mutable_device_descriptor() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.DeviceMessage.device_descriptor)
  return _internal_mutable_device_descriptor();
}

// .naki3d.common.protocol.Ping ping = 17;
inline bool DeviceMessage::_internal_has_ping() const {
  return message_case() == kPing;
}
inline bool DeviceMessage::has_ping() const {
  return _internal_has_ping();
}
inline void DeviceMessage::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline ::naki3d::common::protocol::Ping* DeviceMessage::release_ping() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.DeviceMessage.ping)
  if (_internal_has_ping()) {
    clear_has_message();
      ::naki3d::common::protocol::Ping* temp = message_.ping_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::Ping& DeviceMessage::_internal_ping() const {
  return _internal_has_ping()
      ? *message_.ping_
      : *reinterpret_cast< ::naki3d::common::protocol::Ping*>(&::naki3d::common::protocol::_Ping_default_instance_);
}
inline const ::naki3d::common::protocol::Ping& DeviceMessage::ping() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.DeviceMessage.ping)
  return _internal_ping();
}
inline ::naki3d::common::protocol::Ping* DeviceMessage::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.DeviceMessage.ping)
  if (_internal_has_ping()) {
    clear_has_message();
    ::naki3d::common::protocol::Ping* temp = message_.ping_;
    message_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DeviceMessage::unsafe_arena_set_allocated_ping(::naki3d::common::protocol::Ping* ping) {
  clear_message();
  if (ping) {
    set_has_ping();
    message_.ping_ = ping;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.DeviceMessage.ping)
}
inline ::naki3d::common::protocol::Ping* DeviceMessage::_internal_mutable_ping() {
  if (!_internal_has_ping()) {
    clear_message();
    set_has_ping();
    message_.ping_ = CreateMaybeMessage< ::naki3d::common::protocol::Ping >(GetArena());
  }
  return message_.ping_;
}
inline ::naki3d::common::protocol::Ping* DeviceMessage::mutable_ping() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.DeviceMessage.ping)
  return _internal_mutable_ping();
}

inline bool DeviceMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void DeviceMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline DeviceMessage::MessageCase DeviceMessage::message_case() const {
  return DeviceMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SensorMessage

// string sensor_id = 1;
inline void SensorMessage::clear_sensor_id() {
  sensor_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SensorMessage::sensor_id() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorMessage.sensor_id)
  return _internal_sensor_id();
}
inline void SensorMessage::set_sensor_id(const std::string& value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:naki3d.common.protocol.SensorMessage.sensor_id)
}
inline std::string* SensorMessage::mutable_sensor_id() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorMessage.sensor_id)
  return _internal_mutable_sensor_id();
}
inline const std::string& SensorMessage::_internal_sensor_id() const {
  return sensor_id_.Get();
}
inline void SensorMessage::_internal_set_sensor_id(const std::string& value) {
  
  sensor_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SensorMessage::set_sensor_id(std::string&& value) {
  
  sensor_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:naki3d.common.protocol.SensorMessage.sensor_id)
}
inline void SensorMessage::set_sensor_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sensor_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:naki3d.common.protocol.SensorMessage.sensor_id)
}
inline void SensorMessage::set_sensor_id(const char* value,
    size_t size) {
  
  sensor_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:naki3d.common.protocol.SensorMessage.sensor_id)
}
inline std::string* SensorMessage::_internal_mutable_sensor_id() {
  
  return sensor_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SensorMessage::release_sensor_id() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorMessage.sensor_id)
  return sensor_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SensorMessage::set_allocated_sensor_id(std::string* sensor_id) {
  if (sensor_id != nullptr) {
    
  } else {
    
  }
  sensor_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sensor_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:naki3d.common.protocol.SensorMessage.sensor_id)
}
inline std::string* SensorMessage::unsafe_arena_release_sensor_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorMessage.sensor_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return sensor_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SensorMessage::unsafe_arena_set_allocated_sensor_id(
    std::string* sensor_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (sensor_id != nullptr) {
    
  } else {
    
  }
  sensor_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      sensor_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorMessage.sensor_id)
}

// uint64 timestamp = 2;
inline void SensorMessage::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SensorMessage::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SensorMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorMessage.timestamp)
  return _internal_timestamp();
}
inline void SensorMessage::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
}
inline void SensorMessage::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:naki3d.common.protocol.SensorMessage.timestamp)
}

// .naki3d.common.protocol.MediapipeHandTrackingData handTracking = 15;
inline bool SensorMessage::_internal_has_handtracking() const {
  return data_case() == kHandTracking;
}
inline bool SensorMessage::has_handtracking() const {
  return _internal_has_handtracking();
}
inline void SensorMessage::set_has_handtracking() {
  _oneof_case_[0] = kHandTracking;
}
inline ::naki3d::common::protocol::MediapipeHandTrackingData* SensorMessage::release_handtracking() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorMessage.handTracking)
  if (_internal_has_handtracking()) {
    clear_has_data();
      ::naki3d::common::protocol::MediapipeHandTrackingData* temp = data_.handtracking_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.handtracking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::MediapipeHandTrackingData& SensorMessage::_internal_handtracking() const {
  return _internal_has_handtracking()
      ? *data_.handtracking_
      : *reinterpret_cast< ::naki3d::common::protocol::MediapipeHandTrackingData*>(&::naki3d::common::protocol::_MediapipeHandTrackingData_default_instance_);
}
inline const ::naki3d::common::protocol::MediapipeHandTrackingData& SensorMessage::handtracking() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorMessage.handTracking)
  return _internal_handtracking();
}
inline ::naki3d::common::protocol::MediapipeHandTrackingData* SensorMessage::unsafe_arena_release_handtracking() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorMessage.handTracking)
  if (_internal_has_handtracking()) {
    clear_has_data();
    ::naki3d::common::protocol::MediapipeHandTrackingData* temp = data_.handtracking_;
    data_.handtracking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage::unsafe_arena_set_allocated_handtracking(::naki3d::common::protocol::MediapipeHandTrackingData* handtracking) {
  clear_data();
  if (handtracking) {
    set_has_handtracking();
    data_.handtracking_ = handtracking;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorMessage.handTracking)
}
inline ::naki3d::common::protocol::MediapipeHandTrackingData* SensorMessage::_internal_mutable_handtracking() {
  if (!_internal_has_handtracking()) {
    clear_data();
    set_has_handtracking();
    data_.handtracking_ = CreateMaybeMessage< ::naki3d::common::protocol::MediapipeHandTrackingData >(GetArena());
  }
  return data_.handtracking_;
}
inline ::naki3d::common::protocol::MediapipeHandTrackingData* SensorMessage::mutable_handtracking() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorMessage.handTracking)
  return _internal_mutable_handtracking();
}

// .naki3d.common.protocol.GestureData gesture = 16;
inline bool SensorMessage::_internal_has_gesture() const {
  return data_case() == kGesture;
}
inline bool SensorMessage::has_gesture() const {
  return _internal_has_gesture();
}
inline void SensorMessage::set_has_gesture() {
  _oneof_case_[0] = kGesture;
}
inline ::naki3d::common::protocol::GestureData* SensorMessage::release_gesture() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorMessage.gesture)
  if (_internal_has_gesture()) {
    clear_has_data();
      ::naki3d::common::protocol::GestureData* temp = data_.gesture_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.gesture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::GestureData& SensorMessage::_internal_gesture() const {
  return _internal_has_gesture()
      ? *data_.gesture_
      : *reinterpret_cast< ::naki3d::common::protocol::GestureData*>(&::naki3d::common::protocol::_GestureData_default_instance_);
}
inline const ::naki3d::common::protocol::GestureData& SensorMessage::gesture() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorMessage.gesture)
  return _internal_gesture();
}
inline ::naki3d::common::protocol::GestureData* SensorMessage::unsafe_arena_release_gesture() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorMessage.gesture)
  if (_internal_has_gesture()) {
    clear_has_data();
    ::naki3d::common::protocol::GestureData* temp = data_.gesture_;
    data_.gesture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage::unsafe_arena_set_allocated_gesture(::naki3d::common::protocol::GestureData* gesture) {
  clear_data();
  if (gesture) {
    set_has_gesture();
    data_.gesture_ = gesture;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorMessage.gesture)
}
inline ::naki3d::common::protocol::GestureData* SensorMessage::_internal_mutable_gesture() {
  if (!_internal_has_gesture()) {
    clear_data();
    set_has_gesture();
    data_.gesture_ = CreateMaybeMessage< ::naki3d::common::protocol::GestureData >(GetArena());
  }
  return data_.gesture_;
}
inline ::naki3d::common::protocol::GestureData* SensorMessage::mutable_gesture() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorMessage.gesture)
  return _internal_mutable_gesture();
}

// .naki3d.common.protocol.HandMovementData hand_movement = 17;
inline bool SensorMessage::_internal_has_hand_movement() const {
  return data_case() == kHandMovement;
}
inline bool SensorMessage::has_hand_movement() const {
  return _internal_has_hand_movement();
}
inline void SensorMessage::set_has_hand_movement() {
  _oneof_case_[0] = kHandMovement;
}
inline ::naki3d::common::protocol::HandMovementData* SensorMessage::release_hand_movement() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorMessage.hand_movement)
  if (_internal_has_hand_movement()) {
    clear_has_data();
      ::naki3d::common::protocol::HandMovementData* temp = data_.hand_movement_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.hand_movement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::HandMovementData& SensorMessage::_internal_hand_movement() const {
  return _internal_has_hand_movement()
      ? *data_.hand_movement_
      : *reinterpret_cast< ::naki3d::common::protocol::HandMovementData*>(&::naki3d::common::protocol::_HandMovementData_default_instance_);
}
inline const ::naki3d::common::protocol::HandMovementData& SensorMessage::hand_movement() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorMessage.hand_movement)
  return _internal_hand_movement();
}
inline ::naki3d::common::protocol::HandMovementData* SensorMessage::unsafe_arena_release_hand_movement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorMessage.hand_movement)
  if (_internal_has_hand_movement()) {
    clear_has_data();
    ::naki3d::common::protocol::HandMovementData* temp = data_.hand_movement_;
    data_.hand_movement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage::unsafe_arena_set_allocated_hand_movement(::naki3d::common::protocol::HandMovementData* hand_movement) {
  clear_data();
  if (hand_movement) {
    set_has_hand_movement();
    data_.hand_movement_ = hand_movement;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorMessage.hand_movement)
}
inline ::naki3d::common::protocol::HandMovementData* SensorMessage::_internal_mutable_hand_movement() {
  if (!_internal_has_hand_movement()) {
    clear_data();
    set_has_hand_movement();
    data_.hand_movement_ = CreateMaybeMessage< ::naki3d::common::protocol::HandMovementData >(GetArena());
  }
  return data_.hand_movement_;
}
inline ::naki3d::common::protocol::HandMovementData* SensorMessage::mutable_hand_movement() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorMessage.hand_movement)
  return _internal_mutable_hand_movement();
}

// .naki3d.common.protocol.BestUserChangedData best_user_changed = 18;
inline bool SensorMessage::_internal_has_best_user_changed() const {
  return data_case() == kBestUserChanged;
}
inline bool SensorMessage::has_best_user_changed() const {
  return _internal_has_best_user_changed();
}
inline void SensorMessage::set_has_best_user_changed() {
  _oneof_case_[0] = kBestUserChanged;
}
inline ::naki3d::common::protocol::BestUserChangedData* SensorMessage::release_best_user_changed() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorMessage.best_user_changed)
  if (_internal_has_best_user_changed()) {
    clear_has_data();
      ::naki3d::common::protocol::BestUserChangedData* temp = data_.best_user_changed_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.best_user_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::BestUserChangedData& SensorMessage::_internal_best_user_changed() const {
  return _internal_has_best_user_changed()
      ? *data_.best_user_changed_
      : *reinterpret_cast< ::naki3d::common::protocol::BestUserChangedData*>(&::naki3d::common::protocol::_BestUserChangedData_default_instance_);
}
inline const ::naki3d::common::protocol::BestUserChangedData& SensorMessage::best_user_changed() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorMessage.best_user_changed)
  return _internal_best_user_changed();
}
inline ::naki3d::common::protocol::BestUserChangedData* SensorMessage::unsafe_arena_release_best_user_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorMessage.best_user_changed)
  if (_internal_has_best_user_changed()) {
    clear_has_data();
    ::naki3d::common::protocol::BestUserChangedData* temp = data_.best_user_changed_;
    data_.best_user_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage::unsafe_arena_set_allocated_best_user_changed(::naki3d::common::protocol::BestUserChangedData* best_user_changed) {
  clear_data();
  if (best_user_changed) {
    set_has_best_user_changed();
    data_.best_user_changed_ = best_user_changed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorMessage.best_user_changed)
}
inline ::naki3d::common::protocol::BestUserChangedData* SensorMessage::_internal_mutable_best_user_changed() {
  if (!_internal_has_best_user_changed()) {
    clear_data();
    set_has_best_user_changed();
    data_.best_user_changed_ = CreateMaybeMessage< ::naki3d::common::protocol::BestUserChangedData >(GetArena());
  }
  return data_.best_user_changed_;
}
inline ::naki3d::common::protocol::BestUserChangedData* SensorMessage::mutable_best_user_changed() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorMessage.best_user_changed)
  return _internal_mutable_best_user_changed();
}

// .naki3d.common.protocol.KeyboardUpdateData keyboard_update = 19;
inline bool SensorMessage::_internal_has_keyboard_update() const {
  return data_case() == kKeyboardUpdate;
}
inline bool SensorMessage::has_keyboard_update() const {
  return _internal_has_keyboard_update();
}
inline void SensorMessage::set_has_keyboard_update() {
  _oneof_case_[0] = kKeyboardUpdate;
}
inline ::naki3d::common::protocol::KeyboardUpdateData* SensorMessage::release_keyboard_update() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorMessage.keyboard_update)
  if (_internal_has_keyboard_update()) {
    clear_has_data();
      ::naki3d::common::protocol::KeyboardUpdateData* temp = data_.keyboard_update_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.keyboard_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::KeyboardUpdateData& SensorMessage::_internal_keyboard_update() const {
  return _internal_has_keyboard_update()
      ? *data_.keyboard_update_
      : *reinterpret_cast< ::naki3d::common::protocol::KeyboardUpdateData*>(&::naki3d::common::protocol::_KeyboardUpdateData_default_instance_);
}
inline const ::naki3d::common::protocol::KeyboardUpdateData& SensorMessage::keyboard_update() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorMessage.keyboard_update)
  return _internal_keyboard_update();
}
inline ::naki3d::common::protocol::KeyboardUpdateData* SensorMessage::unsafe_arena_release_keyboard_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorMessage.keyboard_update)
  if (_internal_has_keyboard_update()) {
    clear_has_data();
    ::naki3d::common::protocol::KeyboardUpdateData* temp = data_.keyboard_update_;
    data_.keyboard_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage::unsafe_arena_set_allocated_keyboard_update(::naki3d::common::protocol::KeyboardUpdateData* keyboard_update) {
  clear_data();
  if (keyboard_update) {
    set_has_keyboard_update();
    data_.keyboard_update_ = keyboard_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorMessage.keyboard_update)
}
inline ::naki3d::common::protocol::KeyboardUpdateData* SensorMessage::_internal_mutable_keyboard_update() {
  if (!_internal_has_keyboard_update()) {
    clear_data();
    set_has_keyboard_update();
    data_.keyboard_update_ = CreateMaybeMessage< ::naki3d::common::protocol::KeyboardUpdateData >(GetArena());
  }
  return data_.keyboard_update_;
}
inline ::naki3d::common::protocol::KeyboardUpdateData* SensorMessage::mutable_keyboard_update() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorMessage.keyboard_update)
  return _internal_mutable_keyboard_update();
}

// .naki3d.common.protocol.MouseMoveData mouse_move = 20;
inline bool SensorMessage::_internal_has_mouse_move() const {
  return data_case() == kMouseMove;
}
inline bool SensorMessage::has_mouse_move() const {
  return _internal_has_mouse_move();
}
inline void SensorMessage::set_has_mouse_move() {
  _oneof_case_[0] = kMouseMove;
}
inline ::naki3d::common::protocol::MouseMoveData* SensorMessage::release_mouse_move() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorMessage.mouse_move)
  if (_internal_has_mouse_move()) {
    clear_has_data();
      ::naki3d::common::protocol::MouseMoveData* temp = data_.mouse_move_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.mouse_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::MouseMoveData& SensorMessage::_internal_mouse_move() const {
  return _internal_has_mouse_move()
      ? *data_.mouse_move_
      : *reinterpret_cast< ::naki3d::common::protocol::MouseMoveData*>(&::naki3d::common::protocol::_MouseMoveData_default_instance_);
}
inline const ::naki3d::common::protocol::MouseMoveData& SensorMessage::mouse_move() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorMessage.mouse_move)
  return _internal_mouse_move();
}
inline ::naki3d::common::protocol::MouseMoveData* SensorMessage::unsafe_arena_release_mouse_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorMessage.mouse_move)
  if (_internal_has_mouse_move()) {
    clear_has_data();
    ::naki3d::common::protocol::MouseMoveData* temp = data_.mouse_move_;
    data_.mouse_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage::unsafe_arena_set_allocated_mouse_move(::naki3d::common::protocol::MouseMoveData* mouse_move) {
  clear_data();
  if (mouse_move) {
    set_has_mouse_move();
    data_.mouse_move_ = mouse_move;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorMessage.mouse_move)
}
inline ::naki3d::common::protocol::MouseMoveData* SensorMessage::_internal_mutable_mouse_move() {
  if (!_internal_has_mouse_move()) {
    clear_data();
    set_has_mouse_move();
    data_.mouse_move_ = CreateMaybeMessage< ::naki3d::common::protocol::MouseMoveData >(GetArena());
  }
  return data_.mouse_move_;
}
inline ::naki3d::common::protocol::MouseMoveData* SensorMessage::mutable_mouse_move() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorMessage.mouse_move)
  return _internal_mutable_mouse_move();
}

// .naki3d.common.protocol.MouseButtonData mouse_button = 21;
inline bool SensorMessage::_internal_has_mouse_button() const {
  return data_case() == kMouseButton;
}
inline bool SensorMessage::has_mouse_button() const {
  return _internal_has_mouse_button();
}
inline void SensorMessage::set_has_mouse_button() {
  _oneof_case_[0] = kMouseButton;
}
inline ::naki3d::common::protocol::MouseButtonData* SensorMessage::release_mouse_button() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorMessage.mouse_button)
  if (_internal_has_mouse_button()) {
    clear_has_data();
      ::naki3d::common::protocol::MouseButtonData* temp = data_.mouse_button_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.mouse_button_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::MouseButtonData& SensorMessage::_internal_mouse_button() const {
  return _internal_has_mouse_button()
      ? *data_.mouse_button_
      : *reinterpret_cast< ::naki3d::common::protocol::MouseButtonData*>(&::naki3d::common::protocol::_MouseButtonData_default_instance_);
}
inline const ::naki3d::common::protocol::MouseButtonData& SensorMessage::mouse_button() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorMessage.mouse_button)
  return _internal_mouse_button();
}
inline ::naki3d::common::protocol::MouseButtonData* SensorMessage::unsafe_arena_release_mouse_button() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorMessage.mouse_button)
  if (_internal_has_mouse_button()) {
    clear_has_data();
    ::naki3d::common::protocol::MouseButtonData* temp = data_.mouse_button_;
    data_.mouse_button_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage::unsafe_arena_set_allocated_mouse_button(::naki3d::common::protocol::MouseButtonData* mouse_button) {
  clear_data();
  if (mouse_button) {
    set_has_mouse_button();
    data_.mouse_button_ = mouse_button;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorMessage.mouse_button)
}
inline ::naki3d::common::protocol::MouseButtonData* SensorMessage::_internal_mutable_mouse_button() {
  if (!_internal_has_mouse_button()) {
    clear_data();
    set_has_mouse_button();
    data_.mouse_button_ = CreateMaybeMessage< ::naki3d::common::protocol::MouseButtonData >(GetArena());
  }
  return data_.mouse_button_;
}
inline ::naki3d::common::protocol::MouseButtonData* SensorMessage::mutable_mouse_button() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorMessage.mouse_button)
  return _internal_mutable_mouse_button();
}

// .naki3d.common.protocol.MouseScrollData mouse_scroll = 22;
inline bool SensorMessage::_internal_has_mouse_scroll() const {
  return data_case() == kMouseScroll;
}
inline bool SensorMessage::has_mouse_scroll() const {
  return _internal_has_mouse_scroll();
}
inline void SensorMessage::set_has_mouse_scroll() {
  _oneof_case_[0] = kMouseScroll;
}
inline ::naki3d::common::protocol::MouseScrollData* SensorMessage::release_mouse_scroll() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorMessage.mouse_scroll)
  if (_internal_has_mouse_scroll()) {
    clear_has_data();
      ::naki3d::common::protocol::MouseScrollData* temp = data_.mouse_scroll_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.mouse_scroll_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::MouseScrollData& SensorMessage::_internal_mouse_scroll() const {
  return _internal_has_mouse_scroll()
      ? *data_.mouse_scroll_
      : *reinterpret_cast< ::naki3d::common::protocol::MouseScrollData*>(&::naki3d::common::protocol::_MouseScrollData_default_instance_);
}
inline const ::naki3d::common::protocol::MouseScrollData& SensorMessage::mouse_scroll() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorMessage.mouse_scroll)
  return _internal_mouse_scroll();
}
inline ::naki3d::common::protocol::MouseScrollData* SensorMessage::unsafe_arena_release_mouse_scroll() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorMessage.mouse_scroll)
  if (_internal_has_mouse_scroll()) {
    clear_has_data();
    ::naki3d::common::protocol::MouseScrollData* temp = data_.mouse_scroll_;
    data_.mouse_scroll_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage::unsafe_arena_set_allocated_mouse_scroll(::naki3d::common::protocol::MouseScrollData* mouse_scroll) {
  clear_data();
  if (mouse_scroll) {
    set_has_mouse_scroll();
    data_.mouse_scroll_ = mouse_scroll;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorMessage.mouse_scroll)
}
inline ::naki3d::common::protocol::MouseScrollData* SensorMessage::_internal_mutable_mouse_scroll() {
  if (!_internal_has_mouse_scroll()) {
    clear_data();
    set_has_mouse_scroll();
    data_.mouse_scroll_ = CreateMaybeMessage< ::naki3d::common::protocol::MouseScrollData >(GetArena());
  }
  return data_.mouse_scroll_;
}
inline ::naki3d::common::protocol::MouseScrollData* SensorMessage::mutable_mouse_scroll() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorMessage.mouse_scroll)
  return _internal_mutable_mouse_scroll();
}

// .naki3d.common.protocol.UltrasonicDistanceData ultrasonic_distance = 23;
inline bool SensorMessage::_internal_has_ultrasonic_distance() const {
  return data_case() == kUltrasonicDistance;
}
inline bool SensorMessage::has_ultrasonic_distance() const {
  return _internal_has_ultrasonic_distance();
}
inline void SensorMessage::set_has_ultrasonic_distance() {
  _oneof_case_[0] = kUltrasonicDistance;
}
inline ::naki3d::common::protocol::UltrasonicDistanceData* SensorMessage::release_ultrasonic_distance() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorMessage.ultrasonic_distance)
  if (_internal_has_ultrasonic_distance()) {
    clear_has_data();
      ::naki3d::common::protocol::UltrasonicDistanceData* temp = data_.ultrasonic_distance_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.ultrasonic_distance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::UltrasonicDistanceData& SensorMessage::_internal_ultrasonic_distance() const {
  return _internal_has_ultrasonic_distance()
      ? *data_.ultrasonic_distance_
      : *reinterpret_cast< ::naki3d::common::protocol::UltrasonicDistanceData*>(&::naki3d::common::protocol::_UltrasonicDistanceData_default_instance_);
}
inline const ::naki3d::common::protocol::UltrasonicDistanceData& SensorMessage::ultrasonic_distance() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorMessage.ultrasonic_distance)
  return _internal_ultrasonic_distance();
}
inline ::naki3d::common::protocol::UltrasonicDistanceData* SensorMessage::unsafe_arena_release_ultrasonic_distance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorMessage.ultrasonic_distance)
  if (_internal_has_ultrasonic_distance()) {
    clear_has_data();
    ::naki3d::common::protocol::UltrasonicDistanceData* temp = data_.ultrasonic_distance_;
    data_.ultrasonic_distance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage::unsafe_arena_set_allocated_ultrasonic_distance(::naki3d::common::protocol::UltrasonicDistanceData* ultrasonic_distance) {
  clear_data();
  if (ultrasonic_distance) {
    set_has_ultrasonic_distance();
    data_.ultrasonic_distance_ = ultrasonic_distance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorMessage.ultrasonic_distance)
}
inline ::naki3d::common::protocol::UltrasonicDistanceData* SensorMessage::_internal_mutable_ultrasonic_distance() {
  if (!_internal_has_ultrasonic_distance()) {
    clear_data();
    set_has_ultrasonic_distance();
    data_.ultrasonic_distance_ = CreateMaybeMessage< ::naki3d::common::protocol::UltrasonicDistanceData >(GetArena());
  }
  return data_.ultrasonic_distance_;
}
inline ::naki3d::common::protocol::UltrasonicDistanceData* SensorMessage::mutable_ultrasonic_distance() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorMessage.ultrasonic_distance)
  return _internal_mutable_ultrasonic_distance();
}

// .naki3d.common.protocol.LightLevelData light_level = 24;
inline bool SensorMessage::_internal_has_light_level() const {
  return data_case() == kLightLevel;
}
inline bool SensorMessage::has_light_level() const {
  return _internal_has_light_level();
}
inline void SensorMessage::set_has_light_level() {
  _oneof_case_[0] = kLightLevel;
}
inline ::naki3d::common::protocol::LightLevelData* SensorMessage::release_light_level() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorMessage.light_level)
  if (_internal_has_light_level()) {
    clear_has_data();
      ::naki3d::common::protocol::LightLevelData* temp = data_.light_level_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.light_level_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::LightLevelData& SensorMessage::_internal_light_level() const {
  return _internal_has_light_level()
      ? *data_.light_level_
      : *reinterpret_cast< ::naki3d::common::protocol::LightLevelData*>(&::naki3d::common::protocol::_LightLevelData_default_instance_);
}
inline const ::naki3d::common::protocol::LightLevelData& SensorMessage::light_level() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorMessage.light_level)
  return _internal_light_level();
}
inline ::naki3d::common::protocol::LightLevelData* SensorMessage::unsafe_arena_release_light_level() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorMessage.light_level)
  if (_internal_has_light_level()) {
    clear_has_data();
    ::naki3d::common::protocol::LightLevelData* temp = data_.light_level_;
    data_.light_level_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage::unsafe_arena_set_allocated_light_level(::naki3d::common::protocol::LightLevelData* light_level) {
  clear_data();
  if (light_level) {
    set_has_light_level();
    data_.light_level_ = light_level;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorMessage.light_level)
}
inline ::naki3d::common::protocol::LightLevelData* SensorMessage::_internal_mutable_light_level() {
  if (!_internal_has_light_level()) {
    clear_data();
    set_has_light_level();
    data_.light_level_ = CreateMaybeMessage< ::naki3d::common::protocol::LightLevelData >(GetArena());
  }
  return data_.light_level_;
}
inline ::naki3d::common::protocol::LightLevelData* SensorMessage::mutable_light_level() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorMessage.light_level)
  return _internal_mutable_light_level();
}

// .naki3d.common.protocol.EventData event = 25;
inline bool SensorMessage::_internal_has_event() const {
  return data_case() == kEvent;
}
inline bool SensorMessage::has_event() const {
  return _internal_has_event();
}
inline void SensorMessage::set_has_event() {
  _oneof_case_[0] = kEvent;
}
inline ::naki3d::common::protocol::EventData* SensorMessage::release_event() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorMessage.event)
  if (_internal_has_event()) {
    clear_has_data();
      ::naki3d::common::protocol::EventData* temp = data_.event_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::EventData& SensorMessage::_internal_event() const {
  return _internal_has_event()
      ? *data_.event_
      : *reinterpret_cast< ::naki3d::common::protocol::EventData*>(&::naki3d::common::protocol::_EventData_default_instance_);
}
inline const ::naki3d::common::protocol::EventData& SensorMessage::event() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorMessage.event)
  return _internal_event();
}
inline ::naki3d::common::protocol::EventData* SensorMessage::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorMessage.event)
  if (_internal_has_event()) {
    clear_has_data();
    ::naki3d::common::protocol::EventData* temp = data_.event_;
    data_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage::unsafe_arena_set_allocated_event(::naki3d::common::protocol::EventData* event) {
  clear_data();
  if (event) {
    set_has_event();
    data_.event_ = event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorMessage.event)
}
inline ::naki3d::common::protocol::EventData* SensorMessage::_internal_mutable_event() {
  if (!_internal_has_event()) {
    clear_data();
    set_has_event();
    data_.event_ = CreateMaybeMessage< ::naki3d::common::protocol::EventData >(GetArena());
  }
  return data_.event_;
}
inline ::naki3d::common::protocol::EventData* SensorMessage::mutable_event() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorMessage.event)
  return _internal_mutable_event();
}

// .naki3d.common.protocol.PirMovementData pir_movement = 26;
inline bool SensorMessage::_internal_has_pir_movement() const {
  return data_case() == kPirMovement;
}
inline bool SensorMessage::has_pir_movement() const {
  return _internal_has_pir_movement();
}
inline void SensorMessage::set_has_pir_movement() {
  _oneof_case_[0] = kPirMovement;
}
inline ::naki3d::common::protocol::PirMovementData* SensorMessage::release_pir_movement() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorMessage.pir_movement)
  if (_internal_has_pir_movement()) {
    clear_has_data();
      ::naki3d::common::protocol::PirMovementData* temp = data_.pir_movement_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.pir_movement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::PirMovementData& SensorMessage::_internal_pir_movement() const {
  return _internal_has_pir_movement()
      ? *data_.pir_movement_
      : *reinterpret_cast< ::naki3d::common::protocol::PirMovementData*>(&::naki3d::common::protocol::_PirMovementData_default_instance_);
}
inline const ::naki3d::common::protocol::PirMovementData& SensorMessage::pir_movement() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorMessage.pir_movement)
  return _internal_pir_movement();
}
inline ::naki3d::common::protocol::PirMovementData* SensorMessage::unsafe_arena_release_pir_movement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorMessage.pir_movement)
  if (_internal_has_pir_movement()) {
    clear_has_data();
    ::naki3d::common::protocol::PirMovementData* temp = data_.pir_movement_;
    data_.pir_movement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage::unsafe_arena_set_allocated_pir_movement(::naki3d::common::protocol::PirMovementData* pir_movement) {
  clear_data();
  if (pir_movement) {
    set_has_pir_movement();
    data_.pir_movement_ = pir_movement;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorMessage.pir_movement)
}
inline ::naki3d::common::protocol::PirMovementData* SensorMessage::_internal_mutable_pir_movement() {
  if (!_internal_has_pir_movement()) {
    clear_data();
    set_has_pir_movement();
    data_.pir_movement_ = CreateMaybeMessage< ::naki3d::common::protocol::PirMovementData >(GetArena());
  }
  return data_.pir_movement_;
}
inline ::naki3d::common::protocol::PirMovementData* SensorMessage::mutable_pir_movement() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorMessage.pir_movement)
  return _internal_mutable_pir_movement();
}

inline bool SensorMessage::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void SensorMessage::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline SensorMessage::DataCase SensorMessage::data_case() const {
  return SensorMessage::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SensorControlMessage

// string hostname = 1;
inline void SensorControlMessage::clear_hostname() {
  hostname_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SensorControlMessage::hostname() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorControlMessage.hostname)
  return _internal_hostname();
}
inline void SensorControlMessage::set_hostname(const std::string& value) {
  _internal_set_hostname(value);
  // @@protoc_insertion_point(field_set:naki3d.common.protocol.SensorControlMessage.hostname)
}
inline std::string* SensorControlMessage::mutable_hostname() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorControlMessage.hostname)
  return _internal_mutable_hostname();
}
inline const std::string& SensorControlMessage::_internal_hostname() const {
  return hostname_.Get();
}
inline void SensorControlMessage::_internal_set_hostname(const std::string& value) {
  
  hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SensorControlMessage::set_hostname(std::string&& value) {
  
  hostname_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:naki3d.common.protocol.SensorControlMessage.hostname)
}
inline void SensorControlMessage::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:naki3d.common.protocol.SensorControlMessage.hostname)
}
inline void SensorControlMessage::set_hostname(const char* value,
    size_t size) {
  
  hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:naki3d.common.protocol.SensorControlMessage.hostname)
}
inline std::string* SensorControlMessage::_internal_mutable_hostname() {
  
  return hostname_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SensorControlMessage::release_hostname() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorControlMessage.hostname)
  return hostname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SensorControlMessage::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  hostname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:naki3d.common.protocol.SensorControlMessage.hostname)
}
inline std::string* SensorControlMessage::unsafe_arena_release_hostname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorControlMessage.hostname)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return hostname_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SensorControlMessage::unsafe_arena_set_allocated_hostname(
    std::string* hostname) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (hostname != nullptr) {
    
  } else {
    
  }
  hostname_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      hostname, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorControlMessage.hostname)
}

// .naki3d.common.protocol.SensorListRequest sensor_list = 16;
inline bool SensorControlMessage::_internal_has_sensor_list() const {
  return message_case() == kSensorList;
}
inline bool SensorControlMessage::has_sensor_list() const {
  return _internal_has_sensor_list();
}
inline void SensorControlMessage::set_has_sensor_list() {
  _oneof_case_[0] = kSensorList;
}
inline ::naki3d::common::protocol::SensorListRequest* SensorControlMessage::release_sensor_list() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorControlMessage.sensor_list)
  if (_internal_has_sensor_list()) {
    clear_has_message();
      ::naki3d::common::protocol::SensorListRequest* temp = message_.sensor_list_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.sensor_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::SensorListRequest& SensorControlMessage::_internal_sensor_list() const {
  return _internal_has_sensor_list()
      ? *message_.sensor_list_
      : *reinterpret_cast< ::naki3d::common::protocol::SensorListRequest*>(&::naki3d::common::protocol::_SensorListRequest_default_instance_);
}
inline const ::naki3d::common::protocol::SensorListRequest& SensorControlMessage::sensor_list() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorControlMessage.sensor_list)
  return _internal_sensor_list();
}
inline ::naki3d::common::protocol::SensorListRequest* SensorControlMessage::unsafe_arena_release_sensor_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorControlMessage.sensor_list)
  if (_internal_has_sensor_list()) {
    clear_has_message();
    ::naki3d::common::protocol::SensorListRequest* temp = message_.sensor_list_;
    message_.sensor_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorControlMessage::unsafe_arena_set_allocated_sensor_list(::naki3d::common::protocol::SensorListRequest* sensor_list) {
  clear_message();
  if (sensor_list) {
    set_has_sensor_list();
    message_.sensor_list_ = sensor_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorControlMessage.sensor_list)
}
inline ::naki3d::common::protocol::SensorListRequest* SensorControlMessage::_internal_mutable_sensor_list() {
  if (!_internal_has_sensor_list()) {
    clear_message();
    set_has_sensor_list();
    message_.sensor_list_ = CreateMaybeMessage< ::naki3d::common::protocol::SensorListRequest >(GetArena());
  }
  return message_.sensor_list_;
}
inline ::naki3d::common::protocol::SensorListRequest* SensorControlMessage::mutable_sensor_list() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorControlMessage.sensor_list)
  return _internal_mutable_sensor_list();
}

// .naki3d.common.protocol.CECMessage cec_message = 17;
inline bool SensorControlMessage::_internal_has_cec_message() const {
  return message_case() == kCecMessage;
}
inline bool SensorControlMessage::has_cec_message() const {
  return _internal_has_cec_message();
}
inline void SensorControlMessage::set_has_cec_message() {
  _oneof_case_[0] = kCecMessage;
}
inline ::naki3d::common::protocol::CECMessage* SensorControlMessage::release_cec_message() {
  // @@protoc_insertion_point(field_release:naki3d.common.protocol.SensorControlMessage.cec_message)
  if (_internal_has_cec_message()) {
    clear_has_message();
      ::naki3d::common::protocol::CECMessage* temp = message_.cec_message_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.cec_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::naki3d::common::protocol::CECMessage& SensorControlMessage::_internal_cec_message() const {
  return _internal_has_cec_message()
      ? *message_.cec_message_
      : *reinterpret_cast< ::naki3d::common::protocol::CECMessage*>(&::naki3d::common::protocol::_CECMessage_default_instance_);
}
inline const ::naki3d::common::protocol::CECMessage& SensorControlMessage::cec_message() const {
  // @@protoc_insertion_point(field_get:naki3d.common.protocol.SensorControlMessage.cec_message)
  return _internal_cec_message();
}
inline ::naki3d::common::protocol::CECMessage* SensorControlMessage::unsafe_arena_release_cec_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:naki3d.common.protocol.SensorControlMessage.cec_message)
  if (_internal_has_cec_message()) {
    clear_has_message();
    ::naki3d::common::protocol::CECMessage* temp = message_.cec_message_;
    message_.cec_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorControlMessage::unsafe_arena_set_allocated_cec_message(::naki3d::common::protocol::CECMessage* cec_message) {
  clear_message();
  if (cec_message) {
    set_has_cec_message();
    message_.cec_message_ = cec_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:naki3d.common.protocol.SensorControlMessage.cec_message)
}
inline ::naki3d::common::protocol::CECMessage* SensorControlMessage::_internal_mutable_cec_message() {
  if (!_internal_has_cec_message()) {
    clear_message();
    set_has_cec_message();
    message_.cec_message_ = CreateMaybeMessage< ::naki3d::common::protocol::CECMessage >(GetArena());
  }
  return message_.cec_message_;
}
inline ::naki3d::common::protocol::CECMessage* SensorControlMessage::mutable_cec_message() {
  // @@protoc_insertion_point(field_mutable:naki3d.common.protocol.SensorControlMessage.cec_message)
  return _internal_mutable_cec_message();
}

inline bool SensorControlMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void SensorControlMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline SensorControlMessage::MessageCase SensorControlMessage::message_case() const {
  return SensorControlMessage::MessageCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace common
}  // namespace naki3d

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_wrappers_2eproto
